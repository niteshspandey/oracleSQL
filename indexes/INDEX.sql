--INDEX
--ROW ID(HEXADECIMAL VALUE)--PHYSICAL ADDRESS OF ENTRY

SELECT ROWID,E.* FROM EMP E WHERE ROWID='AAAR1oAABAAAbHhAAG';

--AN INDEX IS AN SCHEMA OBJECT THAT CONTAIN AN ENTRY FOR EACH VALUE THAT APPEARS IN THE INDEX COLUMNS OR THE TABLE
--An index is a database structure that provides quick lookup of data in a column or columns of a table
--IT PROVIDE DIRECT,FAST ACCESS TO ROW.ORACLE DATABASE SUPPORT SEVERAL TYPE OF INDEX.

--CREATE INDEX INDEX_NAME ON TABLE_NAME(COLUMN_NAME)

--B-TREE INDEX
--BITMAP INDEX
--FUNCTION BASED INDEX
--REVERSE KEY INDEX
--COMPOSITE INDEX

SELECT * FROM EMP;

--B-TREE INDEX
/*
1.B-TREE STAND FOR BALANCED TREE
2.B-TREE INDEX IS AN ORDERED LIST OF VALUES DIVIDED INTO RANGE.
3.B-TREE USED WHEN DATA IS WIDELY DISTRIBUTED
4.SUITABLE FOR COLUMN CONTAINING HIGH NUMBER OF UNIQUE VALUES.
5.B-TREE IS MOST COMMON TYPE OF DATABASE INDEX(DEFAULT INDEX).

SYNTAX
CREATE INDEX IDX_BTREE_EMP ON EMP_TABLE(EMP_NO);
EXAMPLE-
CREATE INDEX IDX1_BTREE_EMP ON EMP(EMP_NO);

WHERE TO FIND METADATA
--USER_INDEXES
--USER_IND_COLUMNS
--USER_IND_STATISTICS
--USER_IND_EXPRESSIONS

WHERE TO FIND WHETHER INDEX IS USED BY THE QUERY OR NOT
--USE EXPLAIN PLANE(ESTIMATED PLAN)
--BY EXECUTING QUERY(ACTUAL PLAN)(V$SQL TABLE IS USED TO FIND THE SQL_ID AND THEN USED IN V$SQL_PLAN TABLE TO FIND THE COMPLETE DETAILS)
--MONITORING THE INDEX(ALTER INDEX IDX_EMP MONITORING USAGE--DBA_OBJECT_USAGE,V$OBJECT_USAGE TABLE IS USED TO CHECK THAT THE WHICH INDEXES ARE USED OR NOT)

WHEN TO CREATE B-TREE
SUITABLE FOR COLUMN CONTAINING HIGH NUMBER OF UNIQUE VALUE(HIGH CARDINALITY)
EXAMPLE-
  1.ACCOUNT NUMBER IN BANKING SYSTEM.
  2.STUDENT REGISTERED NUMBER
  3.EMPLOYEE ID IN COMPANY
  4.MAIL ID.

WHAT TYPE OF SCAN OPERATION B-TREE WILL DO?
-RANGE SCAN
        ---SCAN FOR RANGE OF VALUE.
        ---FIND THE NEXT VALUE IF FIRST OCCURANCE MATCHED .
        ---SYNTAX CREATE INDEX INDEX_NAME ON TABLE_NAME(COLUMN_NAME)


-UNIQUE SCAN
        ---FASTER AS COMPARED TO RANGE SCAN.
        ---WHEN UNIQUE INDEX CREATED (WHEN FIRST OCCURANCE MATCHED THEN STOPPED THE SEARCHING)
        ---SYNTAX CREATE UNIQUE INDEX INDEX_NAME ON TABLE_NAME(COLUMN_NAME)


-FULL SCAN
        ---IT IS SIMILAR TO FAST FULL SCAN BUT IN THIS ONLY ONE INDEX TABLE USED.
        ---FASTER THEN COMPLETE TABLE SCAN
        ---EG: IF INDEX CREATED ON SALARY COLUMN THEN INSTEAD OF GOING TO MAIN TABLE
               IT DIRECTLY GO TO INDEX SALARY AND RETURN THE RESULT HAVING ONE COLUMN.
        

-FULL SCAN(MIN/MAX)
        ---IF WE FIND THE MIN/MAX OF RESULT SET THEN THIS SCAN ENABLE.
        ---VALUE IS STORED IN SORTED FORM AT THE TIME OF CREATING INDEX WITH ROWID SO 
           IT IS EASY TO FINE AND RETURN THE VALUE.


-FAST FULL SCAN
        ---AVOID TABLE SCAN ,DETAILS FETCHED FROM INDEXED TABLE ONLY
        ---TAKING DATA FROM 2 DIFFERENT CREATED INDEX AND JOIN THE RESULT AS SINGLE RESULTSET

ADVANTAGES
CREATE INDEX TO IMPROVE THE PERFORMANCE

DISADVANTAGES
WHEN DML OPERATION PERFORM IT DEGRADE THE PERFORMANCE

*/

--BITMAP INDEX
/*
1.RECOMMENDED IF DISTINCT VALUE IS LOW OR FOR LOW CARDINALITY.
2.VERY LESS DML ACTIVITY.PREFERABLY READ ONLY TABLES.
3.MULTIPLE LOW CARDINALITY COLUMNS.

ADVANTAGE
PERFORMANCE IMPROVEMENT

DISADVANTAGE
PERFORMANCE DEGRADE WHEN HIGH NO OF DML PERFORMED

CREATE BITMAP INDEX IDX_BITMAP_DEPT_NO ON EMP_TABLE(DEPT_NO)
CREATE BITMAP INDEX IDX2_BITMAP_DEPT_NO ON EMP(DEPT_NO);

select * from V$OPTION WHERE PARAMETER = 'Bit-mapped indexes';
Depending on the edition this feature(Bitmap) is anabled or not:

Express Edition: FALSE
Standard Edition: FALSE
Enterprise Edition: TRUE

*/


--FUNCTION BASED INDEX
/*
1.RECOMMENDED IF ANY EXPRESSION IS USED FOR ANY COLUMN
2.EFFICIENT FOR EVALUATING STATEMENT THAT CONTAIN FUNCTION IN THEIR WHERE CLAUSES.
3.WHEN THE DATABASE PROCESSES THE INSERT AND UPDATE STATEMENT,HOWEVER,IT MUST STILL EVALUATE THE FUNCTION TO PROCESS THE STATEMENT.

CREATE INDEX IDX_FN_ENAME ON EMP_TABLE(UPPER(EMP_NAME))
CREATE INDEX IDX3_FN_EMP_NAME ON EMP(UPPER(EMP_NAME));

DISADVANTAGE
ONLY USED WHEN EXACT EXPRESSION OR FUNCTION IS USED 

*/


--REVERSE KEY INDEX
/*
1.REVERSE KEY INDEX IS TYPE OF B-TREE INDEX THAT PHYSICALLY REVERSE THE BYTES OF EACH
INDEX KEY WHILE KEEPING THE COLUMN ORDER.
2.USED TO AVOID INDEX BLOCK CONTENTION.
3.VALUE SWAP AND THEN STORED,NO SORTING DONE FOR THIS TYPE OF INDEX.

CREATE INDEX IDX_REV_SAL ON EMP_TABLE(SAL) REVERSE;
CREATE INDEX IDX4_REVKEY_SAL ON EMP(SAL) REVERSE;

DISADVANTAGES
  1.NOT SUITABLE FOR RANGE QUERY.

BENEFIT
  1.PERFORMANCE IMPROVEMENT

*/


--COMPOSITE  INDEX
/*
CREATE INDEX ON MORE THEN ONE COLUMN
CREATE INDEX IDX_COMP_EMP ON EMP_TABLE(SAL,DEPT_NO);
CREATE INDEX IDX4_COMP_EMP ON EMP(EMP_NAME,DEPT_NO);
*/

--DATA DICTIONARY
/*USER_INDEXES
SHOW THE INDEX NAME AND TYPE OF INDEX CREATED ON MENTION TABLE
SELECT * FROM USER_INDEXES WHERE TABLE_NAME='EMP';

COLUMN INDEXES
COLUMN NAME ON WHICH INDEX IS CREATED FOR MENTION TABLE
SELECT * FROM USER_IND_COLUMNS WHERE TABLE_NAME='EMP';

STATS INDEXES
GIVE THE BRIEF STATS ABOUNT CREATED INDEX ON MENTION TABLE
SELECT * FROM USER_IND_STATISTICS WHERE TABLE_NAME='EMP';

EXPRESSION BASED INDEX
USED WHEN ANY FUNCTION BASED INDEX IS CREATED.
SELECT * FROM USER_IND_EXPRESSIONS WHERE TABLE_NAME='EMP';
*/

BENEFIT
1.PERFORMANCE IMPROVEMENT

DRAWBACK
1.INDEX CONSUME CONSIDERABLE AMOUNT OF SPACE.
2.INDEX NEED TO BE MANAGED.
3.DML PERFORMANCE MIGHT GET IMPACTED.
